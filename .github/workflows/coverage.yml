name: Report Coverage

on: [pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [13.x]
    steps:
      - name: Checkout code
        uses: actions/checkout@v1
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - name: Environment log
        id: env
        run: |
          echo "::set-output name=yarn-cache-dir::$(yarn cache dir)"
          yarn --version
      - name: Get node_modules cache	
        uses: actions/cache@v1	
        with:	
          path: node_modules	
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}	
          restore-keys: |	
            ${{ runner.os }}-yarn-	
      - name: Get yarn cache	
        uses: actions/cache@v1	
        with:	
          path: ${{ steps.env.outputs.yarn-cache-dir }}	
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}	
          restore-keys: |	
            ${{ runner.os }}-yarn-
      - name: Generate coverage report
        run: |
          yarn --version
          make test-ci-coverage
          # Builds babel-standalone with the regular Babel config
          # test-ci-coverage doesn't test babel-standalone, as trying to gather coverage
          IS_PUBLISH=true make build-standalone
          # data for a JS file that's several megabytes large is bound to fail. Here,
          # we just run the babel-standalone test separately.
          yarn jest "\-standalone/test"
      - run: |
         ps -aux
         free -h
         ping -c 100 127.0.0.1
         free -h
         ping -c 200 127.0.0.1
         free -h
         ps -aux
      - uses: actions/github-script@0.3.0
        with:
            github-token: ${{secrets.GITHUB_TOKEN}}
            script: |
              var fs = require('fs')
              var path = require("path")
              var _FindItem = (function () {
                  function _FindItem(path, level) {
                      this.path = path;
                      this.level = level;
                  }
                  return _FindItem;
              }());
              // normalize the path, otherwise the first result is inconsistently formatted from the rest of the results
              // because path.join() performs normalization.
              let findPath = "${{github.workspace}}";
              // debug trace the parameters
              console.log(`findPath: '${findPath}'`);
              // return empty if not exists
              try {
                  fs.lstatSync(findPath);
              }
              catch (err) {
                  if (err.code == 'ENOENT') {
                      console.log('0 results');
                      return [];
                  }
                  throw err;
              }
              try {
                  var result = [];
                  // push the first item
                  var stack = [new _FindItem(findPath, 1)];
                  var traversalChain = []; // used to detect cycles
                  var _loop_1 = function () {
                      // pop the next item and push to the result array
                      var item = stack.pop();
                      result.push(item.path);
                      // stat the item.  the stat info is used further below to determine whether to traverse deeper
                      //
                      // stat returns info about the target of a symlink (or symlink chain),
                      // lstat returns info about a symlink itself
                      var stats_2 = void 0;
                      // use stat (following all symlinks)
                      stats_2 = fs.statSync(item.path);
                      // note, isDirectory() returns false for the lstat of a symlink
                      if (stats_2.isDirectory()) {
                          console.log("  " + item.path + " (directory)");
                          // get the realpath
                          var realPath_1 = fs.realpathSync(item.path);
                          // fixup the traversal chain to match the item level
                          while (traversalChain.length >= item.level) {
                              traversalChain.pop();
                          }
                          // test for a cycle
                          if (traversalChain.some(function (x) { return x == realPath_1; })) {
                              console.log('    cycle detected:' + realPath_1);
                              return "continue";
                          }
                          // update the traversal chain
                          traversalChain.push(realPath_1);
                          // push the child items in reverse onto the stack
                          var childLevel_1 = item.level + 1;
                          var childItems = fs.readdirSync(item.path)
                              .map(function (childName) { return new _FindItem(path.join(item.path, childName), childLevel_1); });
                          stack.push.apply(stack, childItems.reverse());
                      }
                      else {
                          console.log("  " + item.path + " (file)");
                      }
                  };
                  while (stack.length) {
                      var state_1 = _loop_1();
                      if (state_1 === "continue") continue;
                  }
                  console.log(result.length + " results");
                  return result;
              }
              catch (err) {
                  throw new Error(err.message);
              }

